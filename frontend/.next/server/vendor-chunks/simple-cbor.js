"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-cbor";
exports.ids = ["vendor-chunks/simple-cbor"];
exports.modules = {

/***/ "(ssr)/../../../../../node_modules/simple-cbor/src/index.js":
/*!************************************************************!*\
  !*** ../../../../../node_modules/simple-cbor/src/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./serializer */ \"(ssr)/../../../../../node_modules/simple-cbor/src/serializer.js\"));\nconst value = __importStar(__webpack_require__(/*! ./value */ \"(ssr)/../../../../../node_modules/simple-cbor/src/value.js\"));\nexports.value = value;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyxxRkFBYztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQywyRUFBUztBQUM1QyxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zaW1wbGUtY2Jvci9zcmMvaW5kZXguanM/NzJlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpKTtcbmNvbnN0IHZhbHVlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbHVlXCIpKTtcbmV4cG9ydHMudmFsdWUgPSB2YWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../../../node_modules/simple-cbor/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../../../../node_modules/simple-cbor/src/serializer.js":
/*!*****************************************************************!*\
  !*** ../../../../../node_modules/simple-cbor/src/serializer.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cbor = __importStar(__webpack_require__(/*! ./value */ \"(ssr)/../../../../../node_modules/simple-cbor/src/value.js\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsMkVBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzPzMzYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjYm9yID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbHVlXCIpKTtcbmNvbnN0IEJ1ZmZlckNsYXNzZXMgPSBbXG4gICAgQXJyYXlCdWZmZXIsXG4gICAgVWludDhBcnJheSxcbiAgICBVaW50MTZBcnJheSxcbiAgICBVaW50MzJBcnJheSxcbiAgICBJbnQ4QXJyYXksXG4gICAgSW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LFxuICAgIEZsb2F0MzJBcnJheSxcbiAgICBGbG9hdDY0QXJyYXksXG5dO1xuY2xhc3MgSnNvbkRlZmF1bHRDYm9yRW5jb2RlciB7XG4gICAgLy8gQHBhcmFtIF9zZXJpYWxpemVyIFRoZSBDQk9SIFNlcmlhbGl6ZXIgdG8gdXNlLlxuICAgIC8vIEBwYXJhbSBfc3RhYmxlIFdoZXRoZXIgb3Igbm90IGtleXMgZnJvbSBvYmplY3RzIHNob3VsZCBiZSBzb3J0ZWQgKHN0YWJsZSkuIFRoaXMgaXNcbiAgICAvLyAgICAgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHRlc3RpbmcgZW5jb2RpbmdzIGJldHdlZW4gSlNPTiBvYmplY3RzLlxuICAgIGNvbnN0cnVjdG9yKF9zZXJpYWxpemVyLCBfc3RhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplciA9IF9zZXJpYWxpemVyO1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBfc3RhYmxlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcImpzb25EZWZhdWx0XCI7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtMTAwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW1widW5kZWZpbmVkXCIsIFwiYm9vbGVhblwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcIm9iamVjdFwiXS5pbmRleE9mKHR5cGVvZiB2YWx1ZSkgIT0gLTE7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLnVuZGVmaW5lZF8oKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuYm9vbCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5udW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuZG91YmxlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5zdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5udWxsXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5hcnJheSh2YWx1ZS5tYXAoKHgpID0+IHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoeCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnVmZmVyQ2xhc3Nlcy5maW5kKCh4KSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmJ5dGVzKHZhbHVlLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5pbmRleE9mKFwidG9KU09OXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUodmFsdWUudG9KU09OKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoa2V5LCB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZVZhbHVlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5tYXAobSwgdGhpcy5fc3RhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNldChrZXksIHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm1hcChtLCB0aGlzLl9zdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkpzb25EZWZhdWx0Q2JvckVuY29kZXIgPSBKc29uRGVmYXVsdENib3JFbmNvZGVyO1xuY2xhc3MgVG9DYm9yRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiY2JvckVuY29kZXJcIjtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC05MDtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZVtcInRvQ0JPUlwiXSA9PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9DQk9SKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub0Nib3JFbmNvZGVyID0gVG9DYm9yRW5jb2RlcjtcbmNsYXNzIENib3JTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHN0YXRpYyB3aXRoRGVmYXVsdEVuY29kZXJzKHN0YWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgdGhpcygpO1xuICAgICAgICBzLmFkZEVuY29kZXIobmV3IEpzb25EZWZhdWx0Q2JvckVuY29kZXIocywgc3RhYmxlKSk7XG4gICAgICAgIHMuYWRkRW5jb2RlcihuZXcgVG9DYm9yRW5jb2RlcigpKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHJlbW92ZUVuY29kZXIobmFtZSkge1xuICAgICAgICAvLyBIYXMgdG8gbWFrZSBhbiBleHRyYSBjYWxsIHRvIHZhbHVlcygpIHRvIGVuc3VyZSBpdCBkb2Vzbid0IGJyZWFrIG9uIGl0ZXJhdGlvbi5cbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIHRoaXMuX2VuY29kZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlci5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVycy5kZWxldGUoZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW5jb2RlcihlbmNvZGVyKSB7XG4gICAgICAgIHRoaXMuX2VuY29kZXJzLmFkZChlbmNvZGVyKTtcbiAgICB9XG4gICAgZ2V0RW5jb2RlckZvcih2YWx1ZSkge1xuICAgICAgICBsZXQgY2hvc2VuRW5jb2RlciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlciBvZiB0aGlzLl9lbmNvZGVycykge1xuICAgICAgICAgICAgaWYgKCFjaG9zZW5FbmNvZGVyIHx8IGVuY29kZXIucHJpb3JpdHkgPiBjaG9zZW5FbmNvZGVyLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIubWF0Y2godmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob3NlbkVuY29kZXIgPSBlbmNvZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvc2VuRW5jb2RlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYW4gZW5jb2RlciBmb3IgdmFsdWUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9zZW5FbmNvZGVyO1xuICAgIH1cbiAgICBzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyRm9yKHZhbHVlKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2JvclNlcmlhbGl6ZXIgPSBDYm9yU2VyaWFsaXplcjtcbmNsYXNzIFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyIGV4dGVuZHMgQ2JvclNlcmlhbGl6ZXIge1xuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Jvci5yYXcobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgLy8gU2VsZiBkZXNjcmliZSBDQk9SLlxuICAgICAgICAgICAgLi4ubmV3IFVpbnQ4QXJyYXkoWzB4ZDksIDB4ZDksIDB4ZjddKSxcbiAgICAgICAgICAgIC4uLm5ldyBVaW50OEFycmF5KHN1cGVyLnNlcmlhbGl6ZVZhbHVlKHZhbHVlKSksXG4gICAgICAgIF0pKTtcbiAgICB9XG59XG5leHBvcnRzLlNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyID0gU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../../../node_modules/simple-cbor/src/serializer.js\n");

/***/ }),

/***/ "(ssr)/../../../../../node_modules/simple-cbor/src/value.js":
/*!************************************************************!*\
  !*** ../../../../../node_modules/simple-cbor/src/value.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zaW1wbGUtY2Jvci9zcmMvdmFsdWUuanM/YTc3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1BWF9VNjRfTlVNQkVSID0gMHgyMDAwMDAwMDAwMDAwMDtcbmZ1bmN0aW9uIF9jb25jYXQoYSwgLi4uYXJncykge1xuICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGEuYnl0ZUxlbmd0aCArIGFyZ3MucmVkdWNlKChhY2MsIGIpID0+IGFjYyArIGIuYnl0ZUxlbmd0aCwgMCkpO1xuICAgIG5ld0J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYSksIDApO1xuICAgIGxldCBpID0gYS5ieXRlTGVuZ3RoO1xuICAgIGZvciAoY29uc3QgYiBvZiBhcmdzKSB7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGkpO1xuICAgICAgICBpICs9IGIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZmZlci5idWZmZXI7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplVmFsdWUobWFqb3IsIG1pbm9yLCB2YWx1ZSkge1xuICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIHRoYXQncyBub3QgYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLiBUaGVzZSBhcmUgbm90XG4gICAgLy8gY29uc2lkZXJlZCBlcnJvcnMgc2luY2UgdGhlIHZhbHVlIHdhcyBhbHJlYWR5IHZhbGlkYXRlZCBhbmQgdGhleSBtaWdodFxuICAgIC8vIGJlIG51bWJlciBkZWNpbWFscyBvciBzaWduLlxuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW14wLTlhLWZBLUZdL2csIFwiXCIpO1xuICAgIC8vIENyZWF0ZSB0aGUgYnVmZmVyIGZyb20gdGhlIHZhbHVlIHdpdGggbGVmdCBwYWRkaW5nIHdpdGggMC5cbiAgICBjb25zdCBsZW5ndGggPSAyICoqIChtaW5vciAtIDI0IC8qIEludDggKi8pO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoLWxlbmd0aCAqIDIpLnBhZFN0YXJ0KGxlbmd0aCAqIDIsIFwiMFwiKTtcbiAgICBjb25zdCBieXRlcyA9IFsobWFqb3IgPDwgNSkgKyBtaW5vcl0uY29uY2F0KHZhbHVlLm1hdGNoKC8uLi9nKS5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZU51bWJlcihtYWpvciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhtYWpvciA8PCA1KSArIHZhbHVlXSkuYnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlub3IgPSB2YWx1ZSA8PSAweGZmXG4gICAgICAgICAgICA/IDI0IC8qIEludDggKi9cbiAgICAgICAgICAgIDogdmFsdWUgPD0gMHhmZmZmXG4gICAgICAgICAgICAgICAgPyAyNSAvKiBJbnQxNiAqL1xuICAgICAgICAgICAgICAgIDogdmFsdWUgPD0gMHhmZmZmZmZmZlxuICAgICAgICAgICAgICAgICAgICA/IDI2IC8qIEludDMyICovXG4gICAgICAgICAgICAgICAgICAgIDogMjcgLyogSW50NjQgKi87XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUobWFqb3IsIG1pbm9yLCB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgdXRmOCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goY2hhcmNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLCAweDgwIHwgKChjaGFyY29kZSA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNoYXJjb2RlID0gKChjaGFyY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PiAxOCksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDEyKSAmIDB4M2YpLCAweDgwIHwgKChjaGFyY29kZSA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KF9zZXJpYWxpemVOdW1iZXIoMyAvKiBUZXh0U3RyaW5nICovLCBzdHIubGVuZ3RoKSksIG5ldyBVaW50OEFycmF5KHV0ZjgpKTtcbn1cbi8qKlxuICogVGFnIGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHRhZ2dlZCh0YWcsIHZhbHVlKSB7XG4gICAgaWYgKHRhZyA9PSAweGQ5ZDlmNykge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbMHhkOSwgMHhkOSwgMHhmN10pLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0YWcgPCAyNCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbKDYgLyogVGFnICovIDw8IDUpICsgdGFnXSksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbm9yID0gdGFnIDw9IDB4ZmZcbiAgICAgICAgICAgID8gMjQgLyogSW50OCAqL1xuICAgICAgICAgICAgOiB0YWcgPD0gMHhmZmZmXG4gICAgICAgICAgICAgICAgPyAyNSAvKiBJbnQxNiAqL1xuICAgICAgICAgICAgICAgIDogdGFnIDw9IDB4ZmZmZmZmZmZcbiAgICAgICAgICAgICAgICAgICAgPyAyNiAvKiBJbnQzMiAqL1xuICAgICAgICAgICAgICAgICAgICA6IDI3IC8qIEludDY0ICovO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAyICoqIChtaW5vciAtIDI0IC8qIEludDggKi8pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ1xuICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgLnNsaWNlKC1sZW5ndGggKiAyKVxuICAgICAgICAgICAgLnBhZFN0YXJ0KGxlbmd0aCAqIDIsIFwiMFwiKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbKDYgLyogVGFnICovIDw8IDUpICsgbWlub3JdLmNvbmNhdCh2YWx1ZS5tYXRjaCgvLi4vZykubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy50YWdnZWQgPSB0YWdnZWQ7XG4vKipcbiAqIFNldCB0aGUgcmF3IGJ5dGVzIGNvbnRhaW5lZCBieSB0aGlzIHZhbHVlLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgd2l0aCBhbm90aGVyXG4gKiBDYm9yVmFsdWUsIG9yIGlmIHlvdSBhcmUgaW1wbGVtZW50aW5nIGV4dGVuc2lvbnMgdG8gQ0JPUi5cbiAqIEBwYXJhbSBieXRlcyBBIGJ1ZmZlciBjb250YWluaW5nIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmF3KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5leHBvcnRzLnJhdyA9IHJhdztcbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIHRoYXQgaXMgYmV0d2VlbiBbMCwgMjNdLlxuICogQHBhcmFtIG5cbiAqL1xuZnVuY3Rpb24gdVNtYWxsKG4pIHtcbiAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIG4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBuKSwgMjMpOyAvLyBDbGFtcCBpdC5cbiAgICBjb25zdCBieXRlcyA9IFsoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8gPDwgNSkgKyBuXTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmV4cG9ydHMudVNtYWxsID0gdVNtYWxsO1xuZnVuY3Rpb24gdTgodTgsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTggaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIHU4ID0gcGFyc2VJbnQoXCJcIiArIHU4LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHU4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdTggPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1OCksIDB4ZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1OCA9IHU4LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNCAvKiBJbnQ4ICovLCB1OCk7XG59XG5leHBvcnRzLnU4ID0gdTg7XG5mdW5jdGlvbiB1MTYodTE2LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHUxNiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTE2ID0gcGFyc2VJbnQoXCJcIiArIHUxNiwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1MTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1MTYgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1MTYpLCAweGZmZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1MTYgPSB1MTYudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI1IC8qIEludDE2ICovLCB1MTYpO1xufVxuZXhwb3J0cy51MTYgPSB1MTY7XG5mdW5jdGlvbiB1MzIodTMyLCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHUzMiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTMyID0gcGFyc2VJbnQoXCJcIiArIHUzMiwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1MzIpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1MzIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1MzIpLCAweGZmZmZmZmZmKTsgLy8gQ2xhbXAgaXQuXG4gICAgdTMyID0gdTMyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNiAvKiBJbnQzMiAqLywgdTMyKTtcbn1cbmV4cG9ydHMudTMyID0gdTMyO1xuZnVuY3Rpb24gdTY0KHU2NCwgcmFkaXgpIHtcbiAgICAvLyBTcGVjaWFsIGNvbnNpZGVyYXRpb24gZm9yIG51bWJlcnMgdGhhdCBtaWdodCBiZSBsYXJnZXIgdGhhbiBleHBlY3RlZC5cbiAgICBpZiAodHlwZW9mIHU2NCA9PSBcInN0cmluZ1wiICYmIHJhZGl4ID09IDE2KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBndWFyYW50ZWUgd2UnbGwgZW5jb2RlIHRoZSBudW1iZXIgZGlyZWN0bHkuXG4gICAgICAgIC8vIFZhbGlkYXRlIGl0J3MgYWxsIGhleGFkZWNpbWFsIGZpcnN0LlxuICAgICAgICBpZiAodTY0Lm1hdGNoKC9bXjAtOWEtZkEtRl0vKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIHU2NCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIHU2NCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTY0ID0gcGFyc2VJbnQoXCJcIiArIHU2NCwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1NjQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1NjQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1NjQpLCBNQVhfVTY0X05VTUJFUik7IC8vIENsYW1wIGl0IHRvIGFjdHVhbCBsaW1pdC5cbiAgICB1NjQgPSB1NjQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI3IC8qIEludDY0ICovLCB1NjQpO1xufVxuZXhwb3J0cy51NjQgPSB1NjQ7XG4vKipcbiAqIEVuY29kZSBhIG5lZ2F0aXZlIG51bWJlciB0aGF0IGlzIGJldHdlZW4gWy0yNCwgLTFdLlxuICovXG5mdW5jdGlvbiBpU21hbGwobikge1xuICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVTbWFsbCgwKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCB0byBbMSwgMjRdLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIG4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtbiksIDI0KSAtIDE7XG4gICAgY29uc3QgYnl0ZXMgPSBbKDEgLyogU2lnbmVkSW50ZWdlciAqLyA8PCA1KSArIG5dO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZXhwb3J0cy5pU21hbGwgPSBpU21hbGw7XG5mdW5jdGlvbiBpOChpOCwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpOCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTggPSBwYXJzZUludChcIlwiICsgaTgsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGk4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWk4IC0gMSksIDB4ZmYpO1xuICAgIGk4ID0gaTgudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNCAvKiBJbnQ4ICovLCBpOCk7XG59XG5leHBvcnRzLmk4ID0gaTg7XG5mdW5jdGlvbiBpMTYoaTE2LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGkxNiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTE2ID0gcGFyc2VJbnQoXCJcIiArIGkxNiwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpMTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGkxNiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pMTYgLSAxKSwgMHhmZmZmKTtcbiAgICBpMTYgPSBpMTYudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNSAvKiBJbnQxNiAqLywgaTE2KTtcbn1cbmV4cG9ydHMuaTE2ID0gaTE2O1xuZnVuY3Rpb24gaTMyKGkzMiwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpMzIgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIGkzMiA9IHBhcnNlSW50KFwiXCIgKyBpMzIsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCwgbWludXMgMSAodGhlcmUncyBubyBuZWdhdGl2ZSAwKS5cbiAgICBpMzIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTMyIC0gMSksIDB4ZmZmZmZmZmYpO1xuICAgIGkzMiA9IGkzMi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI2IC8qIEludDMyICovLCBpMzIpO1xufVxuZXhwb3J0cy5pMzIgPSBpMzI7XG5mdW5jdGlvbiBpNjQoaTY0LCByYWRpeCkge1xuICAgIC8vIFNwZWNpYWwgY29uc2lkZXJhdGlvbiBmb3IgbnVtYmVycyB0aGF0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIGV4cGVjdGVkLlxuICAgIGlmICh0eXBlb2YgaTY0ID09IFwic3RyaW5nXCIgJiYgcmFkaXggPT0gMTYpIHtcbiAgICAgICAgaWYgKGk2NC5zdGFydHNXaXRoKFwiLVwiKSkge1xuICAgICAgICAgICAgaTY0ID0gaTY0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xhbXAgaXQuXG4gICAgICAgICAgICBpNjQgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgZ3VhcmFudGVlIHdlJ2xsIGVuY29kZSB0aGUgbnVtYmVyIGRpcmVjdGx5LlxuICAgICAgICAvLyBWYWxpZGF0ZSBpdCdzIGFsbCBoZXhhZGVjaW1hbCBmaXJzdC5cbiAgICAgICAgaWYgKGk2NC5tYXRjaCgvW14wLTlhLWZBLUZdLykgfHwgaTY0Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIC0xIHRvIHRoZSBudW1iZXIuXG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBuZXdJNjQgPSBpNjQuc3BsaXQoXCJcIikucmVkdWNlUmlnaHQoKGFjYywgeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuID0gcGFyc2VJbnQoeCwgMTYpIC0gMTtcbiAgICAgICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi50b1N0cmluZygxNikgKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmXCIgKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbnVtYmVyIHdhcyAwLlxuICAgICAgICAgICAgcmV0dXJuIHU2NCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIG5ld0k2NCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIGk2NCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTY0ID0gcGFyc2VJbnQoXCJcIiArIGk2NCwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpNjQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICBpNjQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTY0IC0gMSksIDB4MjAwMDAwMDAwMDAwMDApOyAvLyBDbGFtcCBpdCB0byBhY3R1YWwuXG4gICAgaTY0ID0gaTY0LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIGk2NCk7XG59XG5leHBvcnRzLmk2NCA9IGk2NDtcbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIHVzaW5nIHRoZSBzbWFsbGVzdCBhbW91bnQgb2YgYnl0ZXMsIGJ5IGNhbGxpbmcgdGhlIG1ldGhvZHNcbiAqIGFib3ZlLiBlLmcuIElmIHRoZSBudW1iZXIgZml0cyBpbiBhIHU4LCBpdCB3aWxsIHVzZSB0aGF0LlxuICovXG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmIChuID49IDApIHtcbiAgICAgICAgaWYgKG4gPCAyNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVTbWFsbChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1OChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIHUxNihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1MzIobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdTY0KG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobiA+PSAtMjQpIHtcbiAgICAgICAgICAgIHJldHVybiBpU21hbGwobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAtMHhmZikge1xuICAgICAgICAgICAgcmV0dXJuIGk4KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPj0gLTB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIGkxNihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IC0weGZmZmZmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTMyKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGk2NChuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuLyoqXG4gKiBFbmNvZGUgYSBieXRlIGFycmF5LiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBgcmF3KClgIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXMoYnl0ZXMpIHtcbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDIgLyogQnl0ZVN0cmluZyAqLywgYnl0ZXMuYnl0ZUxlbmd0aCksIGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbi8qKlxuICogRW5jb2RlIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVN0cmluZyhzdHIpO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKipcbiAqIEVuY29kZSBhbiBhcnJheSBvZiBjYm9yIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXkoaXRlbXMpIHtcbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDQgLyogQXJyYXkgKi8sIGl0ZW1zLmxlbmd0aCksIC4uLml0ZW1zKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbi8qKlxuICogRW5jb2RlIGEgbWFwIG9mIGtleS12YWx1ZSBwYWlycy4gVGhlIGtleXMgYXJlIHN0cmluZywgYW5kIHRoZSB2YWx1ZXMgYXJlIENCT1JcbiAqIGVuY29kZWQuXG4gKi9cbmZ1bmN0aW9uIG1hcChpdGVtcywgc3RhYmxlID0gZmFsc2UpIHtcbiAgICBpZiAoIShpdGVtcyBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgaXRlbXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGl0ZW1zKSk7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShpdGVtcy5lbnRyaWVzKCkpO1xuICAgIGlmIChzdGFibGUpIHtcbiAgICAgICAgZW50cmllcyA9IGVudHJpZXMuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IGtleUEubG9jYWxlQ29tcGFyZShrZXlCKSk7XG4gICAgfVxuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoNSAvKiBNYXAgKi8sIGl0ZW1zLnNpemUpLCAuLi5lbnRyaWVzLm1hcCgoW2ssIHZdKSA9PiBfY29uY2F0KF9zZXJpYWxpemVTdHJpbmcoayksIHYpKSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8qKlxuICogRW5jb2RlIGEgc2luZ2xlICgzMiBiaXRzKSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBzaW5nbGVGbG9hdChmKSB7XG4gICAgY29uc3Qgc2luZ2xlID0gbmV3IEZsb2F0MzJBcnJheShbZl0pO1xuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDI2XSksIG5ldyBVaW50OEFycmF5KHNpbmdsZS5idWZmZXIpKTtcbn1cbmV4cG9ydHMuc2luZ2xlRmxvYXQgPSBzaW5nbGVGbG9hdDtcbi8qKlxuICogRW5jb2RlIGEgZG91YmxlICg2NCBiaXRzKSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBkb3VibGVGbG9hdChmKSB7XG4gICAgY29uc3Qgc2luZ2xlID0gbmV3IEZsb2F0NjRBcnJheShbZl0pO1xuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDI3XSksIG5ldyBVaW50OEFycmF5KHNpbmdsZS5idWZmZXIpKTtcbn1cbmV4cG9ydHMuZG91YmxlRmxvYXQgPSBkb3VibGVGbG9hdDtcbmZ1bmN0aW9uIGJvb2wodikge1xuICAgIHJldHVybiB2ID8gdHJ1ZV8oKSA6IGZhbHNlXygpO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbi8qKlxuICogRW5jb2RlIHRoZSBib29sZWFuIHRydWUuXG4gKi9cbmZ1bmN0aW9uIHRydWVfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjFdKSk7XG59XG5leHBvcnRzLnRydWVfID0gdHJ1ZV87XG4vKipcbiAqIEVuY29kZSB0aGUgYm9vbGVhbiBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gZmFsc2VfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjBdKSk7XG59XG5leHBvcnRzLmZhbHNlXyA9IGZhbHNlXztcbi8qKlxuICogRW5jb2RlIHRoZSBjb25zdGFudCBudWxsLlxuICovXG5mdW5jdGlvbiBudWxsXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIyXSkpO1xufVxuZXhwb3J0cy5udWxsXyA9IG51bGxfO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGNvbnN0YW50IHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gdW5kZWZpbmVkXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIzXSkpO1xufVxuZXhwb3J0cy51bmRlZmluZWRfID0gdW5kZWZpbmVkXztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../../../node_modules/simple-cbor/src/value.js\n");

/***/ })

};
;